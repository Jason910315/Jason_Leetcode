## 描述:
Given a 0-indexed integer array nums of size n and two integers lower and upper, return the number of fair pairs.

A pair (i, j) is fair if:

0 <= i < j < n, and
lower <= nums[i] + nums[j] <= upper  

Example 1:  
Input: nums = [0,1,7,4,4,5], lower = 3, upper = 6  
Output: 6  
Explanation: There are 6 fair pairs: (0,3), (0,4), (0,5), (1,3), (1,4), and (1,5).  

Example 2:  
Input: nums = [1,7,9,2,5], lower = 11, upper = 11  
Output: 1  
Explanation: There is a single fair pair: (2,3).
 

Constraints:  
1 <= nums.length <= 105  
nums.length == n  
-109 <= nums[i] <= 109  
-109 <= lower <= upper <= 109  

## 解題思路:
本題要找公平數對的數量，其中公平數對的條件是 lower <= nums[i] + nums[j] <= upper 且 i < j 。  

假設有一數對符合條件，且位置為 (0,5)，則就算排序後位址打亂，但兩者相加還是位於區間內，仍可以成為公平數對，所以位址不影響答案，故可以先排序，目的是為了使用 Binary Search。  

其本質就是找兩個數，看是否在區間內   
=> 枚舉 nums[j]，看 nums[i] 可以是哪些數，題目是要尋找公平數對的「**數量**」，故只要看 nums[i] 有幾個即可。  

**lower <= nums[i] + nums[j] <= upper**
**lower - nums[j] <= nums[i]  <= upper - nums[j]**